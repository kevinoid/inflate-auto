<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016-2017 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>InflateAuto</h1>
      <dl>
        <dt>instantiates without new</dt>
        <dd><pre><code>// eslint-disable-next-line new-cap
const auto = InflateAuto();
assertInstanceOf(auto, InflateAuto);</code></pre></dd>
        <dt>accepts Array-like detectors</dt>
        <dd><pre><code>const auto = new InflateAuto({
  detectors: {
    0: zlib.Gunzip,
    length: 1,
  },
});
assert.deepStrictEqual(auto._detectors, [zlib.Gunzip]);</code></pre></dd>
        <dt>throws TypeError for non-Array-like detectors</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new InflateAuto({ detectors: true }); },
  TypeError,
);</code></pre></dd>
        <dt>throws TypeError for non-function detector</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new InflateAuto({ detectors: [zlib.Gunzip, null] }); },
  TypeError,
);</code></pre></dd>
        <dt>throws TypeError for non-function defaultFormat</dt>
        <dd><pre><code>assert.throws(
  // eslint-disable-next-line no-new
  () =&#x3E; { new InflateAuto({ defaultFormat: true }); },
  TypeError,
);</code></pre></dd>
        <dt>defaultFormat null disables default</dt>
        <dd><pre><code>const auto = new InflateAuto({ defaultFormat: null });
const testData = Buffer.alloc(10);
return assertWriteError(auto, testData, (err) =&#x3E; {
  assert(err, &#x27;expected format mismatch error&#x27;);
  assert(/format/i.test(err.message));
  assert.deepStrictEqual(err.data, testData);
});</code></pre></dd>
        <dt>emits error for format detection error in _transform</dt>
        <dd><pre><code>const inflateAuto = new InflateAuto({ defaultFormat: null });
const zeros = Buffer.alloc(10);
return assertWriteError(inflateAuto, zeros, (err) =&#x3E; {
  assert(err, &#x27;expected format error&#x27;);
  assert(/format/i.test(err.message));
  assert.deepStrictEqual(err.data, zeros);
});</code></pre></dd>
        <section class="suite">
          <h1>.createInflateAuto()</h1>
          <dl>
            <dt>is a factory function</dt>
            <dd><pre><code>const auto = InflateAuto.createInflateAuto();
assertInstanceOf(auto, InflateAuto);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#flush()</h1>
          <dl>
            <dt>calls its callback before format detection</dt>
            <dd><pre><code>const auto = new InflateAuto();
auto.on(&#x27;error&#x27;, done);
auto.flush(done);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getFormat()</h1>
          <dl>
            <dt>returns null before format detection</dt>
            <dd><pre><code>const inflateAuto = new InflateAuto();
assert.strictEqual(inflateAuto.getFormat(), null);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#params()</h1>
          <dl>
            <dt>calls its callback before format detection</dt>
            <dd><pre><code>const auto = new InflateAuto();
auto.on(&#x27;error&#x27;, done);
auto.params(zlib.Z_BEST_COMPRESSION, zlib.Z_FILTERED, done);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>Gzip support</h1>
          <dl>
            <dt>as synchronous function</dt>
            <dd><pre><code>const dataDecompress = decompressSync(compressed);
const dataAuto = InflateAuto.inflateAutoSync(compressed);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
            <dt>single-write with immediate end</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
            <dt>single-write delayed end</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
return Promise.all([
  zlibWriteP.call(zlibStream, compressed),
  autoWriteP.call(inflateAuto, compressed),
]).then(() =&#x3E; {
  result.checkpoint();
  zlibStream.end();
  inflateAuto.end();
  result.checkpoint();
  return result;
});</code></pre></dd>
            <dt>1 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>2 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>3 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>no data after header</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(header);
inflateAuto.end(header);
result.checkpoint();
return result;</code></pre></dd>
            <dt>compressed empty data</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(emptyCompressed);
inflateAuto.end(emptyCompressed);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles truncated compressed data</dt>
            <dd><pre><code>// Truncate shortly after the header (if any) for type detection
const truncated = compressed.slice(0, headerLen + 1);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(truncated);
inflateAuto.end(truncated);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated compressed data</dt>
            <dd><pre><code>const doubledata = Buffer.concat([compressed, compressed]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(doubledata);
inflateAuto.end(doubledata);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated empty compressed data</dt>
            <dd><pre><code>const doubleempty = Buffer.concat([emptyCompressed, emptyCompressed]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(doubleempty);
inflateAuto.end(doubleempty);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated 0</dt>
            <dd><pre><code>const zeros = Buffer.alloc(20);
const compressedWithZeros = Buffer.concat([compressed, zeros]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithZeros);
inflateAuto.end(compressedWithZeros);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated garbage</dt>
            <dd><pre><code>const garbage = Buffer.alloc(20, 42);
const compressedWithGarbage = Buffer.concat([compressed, garbage]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithGarbage);
inflateAuto.end(compressedWithGarbage);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles corrupted compressed data</dt>
            <dd><pre><code>const corrupted = Buffer.from(compressed);
// Leave signature intact
corrupted.fill(42, headerLen);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(corrupted);
inflateAuto.end(corrupted);
result.checkpoint();
return result;</code></pre></dd>
            <dt>corrupted checksum</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const invalid = corruptChecksum(compressed);
zlibStream.end(invalid);
inflateAuto.end(invalid);
result.checkpoint();
return result;</code></pre></dd>
            <dt>emits error for format error in _flush</dt>
            <dd><pre><code>const inflateAuto = new InflateAuto({ defaultFormat: null });
const truncated = compressed.slice(0, 1);
inflateAuto.on(&#x27;error&#x27;, (err) =&#x3E; {
  assert(err, &#x27;expected format error&#x27;);
  assert(/format/i.test(err.message));
  assert.deepStrictEqual(err.data, truncated);
  done();
});
inflateAuto.end(truncated);</code></pre></dd>
            <dt>errors on write of invalid type</dt>
            <dd><pre><code>const options = { objectMode: true };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const compareOptions = { ...COMPARE_OPTIONS };
compareOptions.endEvents = [&#x27;end&#x27;];
// nodejs/node@b514bd231 (Node 8) changed Error to TypeError.
if (nodeVersion[0] &#x3C; 8) {
  compareOptions.compare = compareNoErrorTypes;
}
const result = streamCompare(inflateAuto, zlibStream, compareOptions);
let errInflate;
try {
  zlibStream.write(true);
} catch (err) {
  errInflate = err;
}
let errAuto;
try {
  inflateAuto.write(true);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
            <section class="suite">
              <h1>.inflateAuto</h1>
              <dl>
                <dt>decompresses all data in a single call</dt>
                <dd><pre><code>decompress(compressed, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(compressed, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>handles compressed empty data</dt>
                <dd><pre><code>decompress(emptyCompressed, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(emptyCompressed, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports non-Buffer TypedArray</dt>
                <dd><pre><code>const compressedTA = new Uint8Array(compressed);
decompress(compressedTA, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(compressedTA, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports ArrayBuffer</dt>
                <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
decompress(compressedBuf, (errDecompress, dataDecompress) =&#x3E; {
  InflateAuto.inflateAuto(compressedBuf, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>can accept options argument</dt>
                <dd><pre><code>const opts = { chunkSize: zlib.Z_MIN_CHUNK };
InflateAuto.inflateAuto(compressed, opts, (errAuto, dataAuto) =&#x3E; {
  assert.ifError(errAuto);
  // Node 0.10 does not support opts
  if (decompress.length &#x3C; 3) {
    done();
    return;
  }
  decompress(compressed, opts, (errDecompress, dataDecompress) =&#x3E; {
    assert.ifError(errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports options.info</dt>
                <dd><pre><code>const opts = { info: true };
decompress(compressed, opts, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  assertInstanceOf(dataDecompress.engine, Decompress);
  InflateAuto.inflateAuto(compressed, opts, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assertInstanceOf(dataAuto.engine, InflateAuto);
    dataAuto.engine = dataDecompress.engine;
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>can use PassThrough as defaultFormat</dt>
                <dd><pre><code>const opts = { defaultFormat: stream.PassThrough };
InflateAuto.inflateAuto(uncompressed, opts, (errAuto, dataAuto) =&#x3E; {
  assert.ifError(errAuto);
  assert.deepStrictEqual(dataAuto, uncompressed);
  done();
});</code></pre></dd>
                <dt>handles string defaultEncoding like zlib</dt>
                <dd><pre><code>const compressedStr = compressed.toString(&#x27;binary&#x27;);
const opts = { defaultEncoding: &#x27;binary&#x27; };
decompress(
  compressedStr,
  opts,
  (errDecompress, dataDecompress) =&#x3E; {
    InflateAuto.inflateAuto(
      compressedStr,
      opts,
      (errAuto, dataAuto) =&#x3E; {
        assert.deepStrictEqual(errAuto, errDecompress);
        assert.deepStrictEqual(dataAuto, dataDecompress);
        done();
      },
    );
  },
);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.inflateAutoSync()</h1>
              <dl>
                <dt>invalid type synchronously</dt>
                <dd><pre><code>let errInflate;
try {
  decompressSync(true);
} catch (err) {
  errInflate = err;
}
let errAuto;
try {
  InflateAuto.inflateAutoSync(true);
} catch (err) {
  errAuto = err;
}
if (errAuto &#x26;&#x26; errInflate) {
  // message changed in 2ced07c (Node 8).  Ignore in comparison.
  errAuto.message = errInflate.message;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                <dt>supports non-Buffer TypedArray</dt>
                <dd><pre><code>const compressedTA = new Uint8Array(compressed);
const dataDecompress = decompressSync(compressedTA);
const dataAuto = InflateAuto.inflateAutoSync(compressedTA);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                <dt>supports ArrayBuffer</dt>
                <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
const dataDecompress = decompressSync(compressedBuf);
const dataAuto = InflateAuto.inflateAutoSync(compressedBuf);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                <dt>supports options.info</dt>
                <dd><pre><code>const options = { info: true };
const dataDecompress = decompressSync(compressed, options);
assertInstanceOf(dataDecompress.engine, Decompress);
const dataAuto = InflateAuto.inflateAutoSync(compressed, options);
assertInstanceOf(dataAuto.engine, InflateAuto);
dataAuto.engine = dataDecompress.engine;
assert.deepStrictEqual(dataAuto, dataDecompress);
assert.deepStrictEqual(dataAuto[0], dataDecompress[0]);</code></pre></dd>
                <dt>can use PassThrough as defaultFormat</dt>
                <dd><pre><code>const opts = { defaultFormat: stream.PassThrough };
const dataAuto = InflateAuto.inflateAutoSync(uncompressed, opts);
assert.deepStrictEqual(dataAuto, uncompressed);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>Constructor</h1>
              <dl>
                <dt>supports chunkSize</dt>
                <dd><pre><code>const options = { chunkSize: zlib.Z_MIN_CHUNK };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(largeCompressed);
inflateAuto.end(largeCompressed);
return result;</code></pre></dd>
                <dt>supports finishFlush</dt>
                <dd><pre><code>const options = { finishFlush: zlib.Z_SYNC_FLUSH };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const truncated = largeCompressed.slice(0, -1);
zlibStream.end(truncated);
inflateAuto.end(truncated);
return result;</code></pre></dd>
                <section class="suite">
                  <h1>validates</h1>
                  <dl>
                    <dt>{ chunkSize: 63 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ chunkSize: NaN }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ flush: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ finishFlush: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>emits error</h1>
                  <dl>
                    <dt>synchronously with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>#close()</h1>
              <dl>
                <dt>without writing</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
return new Promise((resolve, reject) =&#x3E; {
  zlibStream.close((...zlibArgs) =&#x3E; {
    inflateAuto.close((...inflateArgs) =&#x3E; {
      // Before nodejs/node#32220 (v14) an error is not passed.
      // Not worth the effort to match this behavior.  Always error.
      if (zlibArgs[0] === undefined) {
        assert.deepStrictEqual(
          inflateArgs.slice(1),
          zlibArgs.slice(1),
          &#x27;same non-err close arguments&#x27;,
        );
        assertInstanceOf(inflateArgs[0], Error);
        assert.deepStrictEqual(
          inflateArgs[0].code,
          &#x27;ERR_STREAM_PREMATURE_CLOSE&#x27;,
        );
      } else {
        assert.deepStrictEqual(
          inflateArgs,
          zlibArgs,
          &#x27;same close arguments&#x27;,
        );
      }
      resolve(result);
    });
  });
});</code></pre></dd>
                <dt>emits once for multiple calls</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
let closeEmitted = false;
inflateAuto.on(&#x27;close&#x27;, () =&#x3E; {
  assert.strictEqual(closeEmitted, false);
  closeEmitted = true;
});
inflateAuto.once(&#x27;close&#x27;, () =&#x3E; {
  inflateAuto.close();
});
inflateAuto.close();
inflateAuto.close();
return new Promise((resolve, reject) =&#x3E; {
  setImmediate(() =&#x3E; {
    assert.strictEqual(closeEmitted, true);
    resolve();
  });
});</code></pre></dd>
                <dt>before #end()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
                <dt>#reset() after #close()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
let errInflate;
try { zlibStream.reset(); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.reset(); } catch (err) { errAuto = err; }
// nodejs/node@6441556 (v6.2.1) changed the assertion to check _handle
// which is null rather than false in this case.
//
// nodejs/node#25956 (v12) changed from ERR_ASSERTION to
// ERR_INTERNAL_ASSERTION.
//
// It&#x27;s not worth complicating the code to mimic this.
assert.deepStrictEqual(
  errAuto instanceof Error,
  errInflate instanceof Error,
);
return result;</code></pre></dd>
                <dt>#write() after #close()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
return new Promise((resolve, reject) =&#x3E; {
  const writeArgsByCall = [];
  function onWrite(...writeArgs) {
    writeArgsByCall.push(writeArgs);
    if (writeArgsByCall.length === 2) {
      assert.deepStrictEqual(writeArgsByCall[0], writeArgsByCall[1]);
      resolve(result);
    }
  }
  zlibStream.write(Buffer.alloc(0), onWrite);
  inflateAuto.write(Buffer.alloc(0), onWrite);
  result.checkpoint();
});</code></pre></dd>
                <dt>errors for non-function truthy argument type</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
let errInflate;
try { zlibStream.close(true); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.close(true); } catch (err) { errAuto = err; }
// In nodejs/node#32220 the error changed from ERR_INVALID_CALLBACK
// to ERR_INVALID_ARG_TYPE (due to calling finished instead of nextTick).
// It&#x27;s not currently worth complicating the code to mimic this.
if (errInflate &#x26;&#x26; errInflate.code === &#x27;ERR_INVALID_CALLBACK&#x27;) {
  assert.deepStrictEqual(errAuto, errInflate);
} else {
  assert.deepStrictEqual(
    errAuto instanceof Error,
    errInflate instanceof Error,
  );
}
// Streams may not emit any events.
// End comparison after event queue clears.
setImmediate(() =&#x3E; result.end());
return result;</code></pre></dd>
                <dt>errors for non-undefined/null falsey argument type</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
let errInflate;
try { zlibStream.close(false); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.close(false); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);
// Streams may not emit any events.
// End comparison after event queue clears.
setImmediate(() =&#x3E; result.end());
return result;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getFormat()</h1>
              <dl>
                <dt>returns format set by #setFormat()</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(Decompress);
assert.strictEqual(inflateAuto.getFormat(), Decompress);</code></pre></dd>
                <dt>returns custom format set by #setFormat()</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(MyDecompress);
assert.strictEqual(inflateAuto.getFormat(), MyDecompress);</code></pre></dd>
                <dt>returns the detected format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.on(&#x27;format&#x27;, () =&#x3E; {
  assert.strictEqual(inflateAuto.getFormat(), Decompress);
  done();
});
inflateAuto.write(compressed);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#flush()</h1>
              <dl>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.flush();
inflateAuto.flush();
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>Z_FINISH before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.flush(zlib.Z_FINISH);
inflateAuto.flush(zlib.Z_FINISH);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.write(compressed.slice(0, 4));
inflateAuto.write(compressed.slice(0, 4));
result.checkpoint();
zlibStream.flush();
inflateAuto.flush();
result.checkpoint();
zlibStream.end(compressed.slice(4));
inflateAuto.end(compressed.slice(4));
result.checkpoint();
return result;</code></pre></dd>
                <dt>Z_FINISH between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.write(compressed.slice(0, 4));
inflateAuto.write(compressed.slice(0, 4));
result.checkpoint();
zlibStream.flush(zlib.Z_FINISH);
inflateAuto.flush(zlib.Z_FINISH);
result.checkpoint();
zlibStream.end(compressed.slice(4));
inflateAuto.end(compressed.slice(4));
result.checkpoint();
return result;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#params()</h1>
              <dl>
                <dt>has the same type</dt>
                <dd><pre><code>let autoType = typeof InflateAuto.prototype.params;
let zlibType = typeof Decompress.prototype.params;
assert.strictEqual(autoType, zlibType);
autoType = typeof new InflateAuto().params;
zlibType = typeof new Decompress().params;
assert.strictEqual(autoType, zlibType);</code></pre></dd>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const level = zlib.Z_BEST_COMPRESSION;
const strategy = zlib.Z_FILTERED;
zlibStream.params(level, strategy, (err) =&#x3E; {
  assert.ifError(err);
  zlibStream.end(compressed);
});
inflateAuto.params(level, strategy, (err) =&#x3E; {
  assert.ifError(err);
  inflateAuto.end(compressed);
});
result.checkpoint();
return result;</code></pre></dd>
                <dt>between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const partial = compressed.slice(0, 4);
return Promise.all([
  zlibWriteP.call(zlibStream, partial),
  autoWriteP.call(inflateAuto, partial),
]).then(() =&#x3E; {
  result.checkpoint();
  const remainder = compressed.slice(4);
  zlibStream.params(
    zlib.Z_BEST_COMPRESSION,
    zlib.Z_FILTERED,
    (err) =&#x3E; {
      assert.ifError(err);
      zlibStream.end(remainder);
    },
  );
  inflateAuto.params(
    zlib.Z_BEST_COMPRESSION,
    zlib.Z_FILTERED,
    (err) =&#x3E; {
      assert.ifError(err);
      inflateAuto.end(remainder);
    },
  );
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#reset()</h1>
              <dl>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.reset();
inflateAuto.reset();
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>discards partial header</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const dataAuto = [];
inflateAuto.on(&#x27;data&#x27;, (data) =&#x3E; {
  dataAuto.push(data);
});
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const partial = compressed.slice(0, 1);
return Promise.all([
  zlibWriteP.call(zlibStream, partial),
  autoWriteP.call(inflateAuto, partial),
]).then(() =&#x3E; {
  result.checkpoint();
  // IMPORTANT:  Can&#x27;t call Zlib.reset() with write in progress
  // Since write is run from uv work queue thread and reset from main
  zlibStream.reset();
  inflateAuto.reset();
  result.checkpoint();
  zlibStream.end(compressed);
  inflateAuto.end(compressed);
  result.checkpoint();
  // Gunzip gained reset in v6.0.0
  // https://github.com/nodejs/node/commit/f380db23
  // If zlib stream emits a header error, test for success instead of ==
  return new Promise((resolve, reject) =&#x3E; {
    let headerError = false;
    zlibStream.once(&#x27;error&#x27;, (err) =&#x3E; {
      if (err.message === &#x27;incorrect header check&#x27;) {
        headerError = true;
        // Comparison result ignored.  Suppress unhandled rejection.
        result.catch((errResult) =&#x3E; {});
      }
    });
    zlibStream.once(&#x27;end&#x27;, () =&#x3E; {
      resolve(result);
    });
    inflateAuto.once(&#x27;end&#x27;, () =&#x3E; {
      assert.deepStrictEqual(Buffer.concat(dataAuto), uncompressed);
      if (headerError) {
        resolve();
      }
    });
  });
});</code></pre></dd>
                <dt>forgets partial header</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
// Note:  Only write to inflateAuto since zlib stream could error on
// first byte due to invalid header.
const autoWriteP = promisify(inflateAuto.write);
// Write data with a different header before reset to check that reset
// clears any partial-header state.
return autoWriteP.call(inflateAuto, otherCompressed.slice(0, 1))
  .then(() =&#x3E; {
    // IMPORTANT:  Can&#x27;t call Zlib.reset() with write in progress
    // Since write is run from uv work queue thread and reset from main
    zlibStream.reset();
    inflateAuto.reset();
    result.checkpoint();
    zlibStream.end(compressed);
    inflateAuto.end(compressed);
    result.checkpoint();
    return result;
  });</code></pre></dd>
                <dt>discards post-header data</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const partial = compressed.slice(0, headerLen + 1);
return Promise.all([
  zlibWriteP.call(zlibStream, partial),
  autoWriteP.call(inflateAuto, partial),
]).then(() =&#x3E; {
  result.checkpoint();
  // IMPORTANT:  Can&#x27;t call Zlib.reset() with write in progress
  // Since write is run from uv work queue thread and reset from main
  zlibStream.reset();
  inflateAuto.reset();
  result.checkpoint();
  zlibStream.end(compressed);
  inflateAuto.end(compressed);
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#setEncoding()</h1>
              <dl>
                <dt>behaves the same before writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.setEncoding(&#x27;utf8&#x27;);
inflateAuto.setEncoding(&#x27;utf8&#x27;);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>behaves the same after format</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const chunk = compressed.slice(0, headerLen + 4);
return Promise.all([
  zlibWriteP.call(zlibStream, chunk),
  autoWriteP.call(inflateAuto, chunk),
]).then(() =&#x3E; {
  result.checkpoint();
  zlibStream.setEncoding(&#x27;utf8&#x27;);
  inflateAuto.setEncoding(&#x27;utf8&#x27;);
  result.checkpoint();
  const rest = compressed.slice(chunk.length);
  zlibStream.end(rest);
  inflateAuto.end(rest);
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#setFormat()</h1>
              <dl>
                <dt>emits &#x27;format&#x27; event with decoder</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
let gotFormat = false;
inflateAuto.on(&#x27;format&#x27;, (decoder) =&#x3E; {
  assert(decoder instanceof Decompress);
  gotFormat = true;
});
inflateAuto.setFormat(Decompress);
assert.strictEqual(gotFormat, true);</code></pre></dd>
                <dt>can set correct format before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>can set incorrect format before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(otherCompressed);
inflateAuto.end(otherCompressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>can set same format twice</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>throws if changing format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(zlib.Inflate);
try {
  inflateAuto.setFormat(zlib.Gunzip);
  throw new Error(&#x27;Should have thrown&#x27;);
} catch (err) {
  assert(/\bformat\b/i.test(err.message));
}</code></pre></dd>
                <dt>throws if changing detected format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.write(otherHeader);
try {
  inflateAuto.setFormat(Decompress);
  throw new Error(&#x27;Should have thrown&#x27;);
} catch (err) {
  assert(/\bformat\b/i.test(err.message));
}</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#_processChunk()</h1>
              <dl>
                <dt>has the same type</dt>
                <dd><pre><code>let autoType = typeof InflateAuto.prototype._processChunk;
let zlibType = typeof Decompress.prototype._processChunk;
assert.strictEqual(autoType, zlibType);
autoType = typeof new InflateAuto()._processChunk;
zlibType = typeof new Decompress()._processChunk;
assert.strictEqual(autoType, zlibType);</code></pre></dd>
                <section class="suite">
                  <h1>with cb</h1>
                  <dl>
                    <dt>works if _transform does not yield synchronously</dt>
                    <dd><pre><code>function AsyncTransform(...args) { stream.Transform.apply(this, args); }
AsyncTransform.prototype = Object.create(stream.Transform.prototype);
AsyncTransform.prototype.constructor = AsyncTransform;
AsyncTransform.prototype._transform = function(data, enc, cb) {
  process.nextTick(() =&#x3E; {
    cb(null, data);
  });
};
const inflateAuto = new InflateAuto({ defaultFormat: AsyncTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH, (err, data) =&#x3E; {
  assert.deepStrictEqual(data, zeros);
  done();
});</code></pre></dd>
                    <dt>buffers inconclusive data</dt>
                    <dd><pre><code>const inflateAuto = new InflateAuto();
const trunc = compressed.slice(0, 1);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
inflateAuto._processChunk(trunc, zlib.Z_NO_FLUSH, (err, data) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(data, undefined);
  done();
});</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>without cb</h1>
                  <dl>
                    <dt>throws if format lacks _processChunk and _transform</dt>
                    <dd><pre><code>function NoTransform(...args) { stream.Duplex.apply(this, args); }
NoTransform.prototype = Object.create(stream.Duplex.prototype);
NoTransform.prototype.constructor = NoTransform;
NoTransform.prototype._read = function() {};
NoTransform.prototype._write = function(chunk, enc, cb) {
  this.push(chunk);
  cb();
};
const inflateAuto = new InflateAuto({ defaultFormat: NoTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH),
  (err) =&#x3E; {
    assert(err instanceof Error);
    assert.strictEqual(err.code, &#x27;ERR_SYNC_NOT_SUPPORTED&#x27;);
    return true;
  },
);</code></pre></dd>
                    <dt>throws if _transform does not yield synchronously</dt>
                    <dd><pre><code>function AsyncTransform(...args) { stream.Transform.apply(this, args); }
AsyncTransform.prototype = Object.create(stream.Transform.prototype);
AsyncTransform.prototype.constructor = AsyncTransform;
AsyncTransform.prototype._transform = function() {};
const inflateAuto = new InflateAuto({ defaultFormat: AsyncTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH),
  (err) =&#x3E; {
    assert(err instanceof Error);
    assert.strictEqual(err.code, &#x27;ERR_SYNC_NOT_SUPPORTED&#x27;);
    return true;
  },
);</code></pre></dd>
                    <dt>throws if _transform yields Error</dt>
                    <dd><pre><code>const errTest = new Error(&#x27;test&#x27;);
function ErrorTransform(...args) { stream.Transform.apply(this, args); }
ErrorTransform.prototype = Object.create(stream.Transform.prototype);
ErrorTransform.prototype.constructor = ErrorTransform;
ErrorTransform.prototype._transform = function(data, enc, cb) {
  cb(errTest);
};
const inflateAuto = new InflateAuto({ defaultFormat: ErrorTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; {
    inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH);
  },
  (err) =&#x3E; err === errTest,
);</code></pre></dd>
                    <dt>supports non-Buffer TypedArray</dt>
                    <dd><pre><code>const compressedTA = new Uint8Array(compressed);
const dataDecompress =
  new Decompress()._processChunk(compressedTA, zlib.Z_FINISH);
const dataAuto =
  new InflateAuto()._processChunk(compressedTA, zlib.Z_FINISH);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                    <dt>supports ArrayBuffer</dt>
                    <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
// As of Node v14, this would cause an assertion failure
// Test that InflateAuto matches Buffer/TypedArray behavior
const dataDecompress =
  new Decompress()._processChunk(compressed, zlib.Z_FINISH);
const dataAuto =
  new InflateAuto()._processChunk(compressedBuf, zlib.Z_FINISH);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                    <dt>throws for invalid chunk type</dt>
                    <dd><pre><code>// As of Node v14, this would cause an assertion failure
// Test that InflateAuto throws TypeError
assert.throws(
  () =&#x3E; new InflateAuto()._processChunk(10, zlib.Z_FINISH),
  TypeError,
);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>Deflate support</h1>
          <dl>
            <dt>as synchronous function</dt>
            <dd><pre><code>const dataDecompress = decompressSync(compressed);
const dataAuto = InflateAuto.inflateAutoSync(compressed);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
            <dt>single-write with immediate end</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
            <dt>single-write delayed end</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
return Promise.all([
  zlibWriteP.call(zlibStream, compressed),
  autoWriteP.call(inflateAuto, compressed),
]).then(() =&#x3E; {
  result.checkpoint();
  zlibStream.end();
  inflateAuto.end();
  result.checkpoint();
  return result;
});</code></pre></dd>
            <dt>1 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>2 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>3 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>no data after header</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(header);
inflateAuto.end(header);
result.checkpoint();
return result;</code></pre></dd>
            <dt>compressed empty data</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(emptyCompressed);
inflateAuto.end(emptyCompressed);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles truncated compressed data</dt>
            <dd><pre><code>// Truncate shortly after the header (if any) for type detection
const truncated = compressed.slice(0, headerLen + 1);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(truncated);
inflateAuto.end(truncated);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated compressed data</dt>
            <dd><pre><code>const doubledata = Buffer.concat([compressed, compressed]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(doubledata);
inflateAuto.end(doubledata);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated empty compressed data</dt>
            <dd><pre><code>const doubleempty = Buffer.concat([emptyCompressed, emptyCompressed]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(doubleempty);
inflateAuto.end(doubleempty);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated 0</dt>
            <dd><pre><code>const zeros = Buffer.alloc(20);
const compressedWithZeros = Buffer.concat([compressed, zeros]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithZeros);
inflateAuto.end(compressedWithZeros);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated garbage</dt>
            <dd><pre><code>const garbage = Buffer.alloc(20, 42);
const compressedWithGarbage = Buffer.concat([compressed, garbage]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithGarbage);
inflateAuto.end(compressedWithGarbage);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles corrupted compressed data</dt>
            <dd><pre><code>const corrupted = Buffer.from(compressed);
// Leave signature intact
corrupted.fill(42, headerLen);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(corrupted);
inflateAuto.end(corrupted);
result.checkpoint();
return result;</code></pre></dd>
            <dt>corrupted checksum</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const invalid = corruptChecksum(compressed);
zlibStream.end(invalid);
inflateAuto.end(invalid);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles dictionary</dt>
            <dd><pre><code>const options = { dictionary: uncompressed };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithDict);
inflateAuto.end(compressedWithDict);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles missing dictionary</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithDict);
inflateAuto.end(compressedWithDict);
result.checkpoint();
return result;</code></pre></dd>
            <dt>emits error for format error in _flush</dt>
            <dd><pre><code>const inflateAuto = new InflateAuto({ defaultFormat: null });
const truncated = compressed.slice(0, 1);
inflateAuto.on(&#x27;error&#x27;, (err) =&#x3E; {
  assert(err, &#x27;expected format error&#x27;);
  assert(/format/i.test(err.message));
  assert.deepStrictEqual(err.data, truncated);
  done();
});
inflateAuto.end(truncated);</code></pre></dd>
            <dt>errors on write of invalid type</dt>
            <dd><pre><code>const options = { objectMode: true };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const compareOptions = { ...COMPARE_OPTIONS };
compareOptions.endEvents = [&#x27;end&#x27;];
// nodejs/node@b514bd231 (Node 8) changed Error to TypeError.
if (nodeVersion[0] &#x3C; 8) {
  compareOptions.compare = compareNoErrorTypes;
}
const result = streamCompare(inflateAuto, zlibStream, compareOptions);
let errInflate;
try {
  zlibStream.write(true);
} catch (err) {
  errInflate = err;
}
let errAuto;
try {
  inflateAuto.write(true);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
            <section class="suite">
              <h1>.inflateAuto</h1>
              <dl>
                <dt>decompresses all data in a single call</dt>
                <dd><pre><code>decompress(compressed, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(compressed, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>handles compressed empty data</dt>
                <dd><pre><code>decompress(emptyCompressed, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(emptyCompressed, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports non-Buffer TypedArray</dt>
                <dd><pre><code>const compressedTA = new Uint8Array(compressed);
decompress(compressedTA, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(compressedTA, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports ArrayBuffer</dt>
                <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
decompress(compressedBuf, (errDecompress, dataDecompress) =&#x3E; {
  InflateAuto.inflateAuto(compressedBuf, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>can accept options argument</dt>
                <dd><pre><code>const opts = { chunkSize: zlib.Z_MIN_CHUNK };
InflateAuto.inflateAuto(compressed, opts, (errAuto, dataAuto) =&#x3E; {
  assert.ifError(errAuto);
  // Node 0.10 does not support opts
  if (decompress.length &#x3C; 3) {
    done();
    return;
  }
  decompress(compressed, opts, (errDecompress, dataDecompress) =&#x3E; {
    assert.ifError(errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports options.info</dt>
                <dd><pre><code>const opts = { info: true };
decompress(compressed, opts, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  assertInstanceOf(dataDecompress.engine, Decompress);
  InflateAuto.inflateAuto(compressed, opts, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assertInstanceOf(dataAuto.engine, InflateAuto);
    dataAuto.engine = dataDecompress.engine;
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>can use PassThrough as defaultFormat</dt>
                <dd><pre><code>const opts = { defaultFormat: stream.PassThrough };
InflateAuto.inflateAuto(uncompressed, opts, (errAuto, dataAuto) =&#x3E; {
  assert.ifError(errAuto);
  assert.deepStrictEqual(dataAuto, uncompressed);
  done();
});</code></pre></dd>
                <dt>handles string defaultEncoding like zlib</dt>
                <dd><pre><code>const compressedStr = compressed.toString(&#x27;binary&#x27;);
const opts = { defaultEncoding: &#x27;binary&#x27; };
decompress(
  compressedStr,
  opts,
  (errDecompress, dataDecompress) =&#x3E; {
    InflateAuto.inflateAuto(
      compressedStr,
      opts,
      (errAuto, dataAuto) =&#x3E; {
        assert.deepStrictEqual(errAuto, errDecompress);
        assert.deepStrictEqual(dataAuto, dataDecompress);
        done();
      },
    );
  },
);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.inflateAutoSync()</h1>
              <dl>
                <dt>invalid type synchronously</dt>
                <dd><pre><code>let errInflate;
try {
  decompressSync(true);
} catch (err) {
  errInflate = err;
}
let errAuto;
try {
  InflateAuto.inflateAutoSync(true);
} catch (err) {
  errAuto = err;
}
if (errAuto &#x26;&#x26; errInflate) {
  // message changed in 2ced07c (Node 8).  Ignore in comparison.
  errAuto.message = errInflate.message;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                <dt>supports non-Buffer TypedArray</dt>
                <dd><pre><code>const compressedTA = new Uint8Array(compressed);
const dataDecompress = decompressSync(compressedTA);
const dataAuto = InflateAuto.inflateAutoSync(compressedTA);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                <dt>supports ArrayBuffer</dt>
                <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
const dataDecompress = decompressSync(compressedBuf);
const dataAuto = InflateAuto.inflateAutoSync(compressedBuf);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                <dt>supports options.info</dt>
                <dd><pre><code>const options = { info: true };
const dataDecompress = decompressSync(compressed, options);
assertInstanceOf(dataDecompress.engine, Decompress);
const dataAuto = InflateAuto.inflateAutoSync(compressed, options);
assertInstanceOf(dataAuto.engine, InflateAuto);
dataAuto.engine = dataDecompress.engine;
assert.deepStrictEqual(dataAuto, dataDecompress);
assert.deepStrictEqual(dataAuto[0], dataDecompress[0]);</code></pre></dd>
                <dt>can use PassThrough as defaultFormat</dt>
                <dd><pre><code>const opts = { defaultFormat: stream.PassThrough };
const dataAuto = InflateAuto.inflateAutoSync(uncompressed, opts);
assert.deepStrictEqual(dataAuto, uncompressed);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>Constructor</h1>
              <dl>
                <dt>supports chunkSize</dt>
                <dd><pre><code>const options = { chunkSize: zlib.Z_MIN_CHUNK };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(largeCompressed);
inflateAuto.end(largeCompressed);
return result;</code></pre></dd>
                <dt>supports finishFlush</dt>
                <dd><pre><code>const options = { finishFlush: zlib.Z_SYNC_FLUSH };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const truncated = largeCompressed.slice(0, -1);
zlibStream.end(truncated);
inflateAuto.end(truncated);
return result;</code></pre></dd>
                <section class="suite">
                  <h1>validates</h1>
                  <dl>
                    <dt>{ chunkSize: 63 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ chunkSize: NaN }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ flush: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ finishFlush: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>emits error</h1>
                  <dl>
                    <dt>synchronously with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>#close()</h1>
              <dl>
                <dt>without writing</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
return new Promise((resolve, reject) =&#x3E; {
  zlibStream.close((...zlibArgs) =&#x3E; {
    inflateAuto.close((...inflateArgs) =&#x3E; {
      // Before nodejs/node#32220 (v14) an error is not passed.
      // Not worth the effort to match this behavior.  Always error.
      if (zlibArgs[0] === undefined) {
        assert.deepStrictEqual(
          inflateArgs.slice(1),
          zlibArgs.slice(1),
          &#x27;same non-err close arguments&#x27;,
        );
        assertInstanceOf(inflateArgs[0], Error);
        assert.deepStrictEqual(
          inflateArgs[0].code,
          &#x27;ERR_STREAM_PREMATURE_CLOSE&#x27;,
        );
      } else {
        assert.deepStrictEqual(
          inflateArgs,
          zlibArgs,
          &#x27;same close arguments&#x27;,
        );
      }
      resolve(result);
    });
  });
});</code></pre></dd>
                <dt>emits once for multiple calls</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
let closeEmitted = false;
inflateAuto.on(&#x27;close&#x27;, () =&#x3E; {
  assert.strictEqual(closeEmitted, false);
  closeEmitted = true;
});
inflateAuto.once(&#x27;close&#x27;, () =&#x3E; {
  inflateAuto.close();
});
inflateAuto.close();
inflateAuto.close();
return new Promise((resolve, reject) =&#x3E; {
  setImmediate(() =&#x3E; {
    assert.strictEqual(closeEmitted, true);
    resolve();
  });
});</code></pre></dd>
                <dt>before #end()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
                <dt>#reset() after #close()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
let errInflate;
try { zlibStream.reset(); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.reset(); } catch (err) { errAuto = err; }
// nodejs/node@6441556 (v6.2.1) changed the assertion to check _handle
// which is null rather than false in this case.
//
// nodejs/node#25956 (v12) changed from ERR_ASSERTION to
// ERR_INTERNAL_ASSERTION.
//
// It&#x27;s not worth complicating the code to mimic this.
assert.deepStrictEqual(
  errAuto instanceof Error,
  errInflate instanceof Error,
);
return result;</code></pre></dd>
                <dt>#write() after #close()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
return new Promise((resolve, reject) =&#x3E; {
  const writeArgsByCall = [];
  function onWrite(...writeArgs) {
    writeArgsByCall.push(writeArgs);
    if (writeArgsByCall.length === 2) {
      assert.deepStrictEqual(writeArgsByCall[0], writeArgsByCall[1]);
      resolve(result);
    }
  }
  zlibStream.write(Buffer.alloc(0), onWrite);
  inflateAuto.write(Buffer.alloc(0), onWrite);
  result.checkpoint();
});</code></pre></dd>
                <dt>errors for non-function truthy argument type</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
let errInflate;
try { zlibStream.close(true); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.close(true); } catch (err) { errAuto = err; }
// In nodejs/node#32220 the error changed from ERR_INVALID_CALLBACK
// to ERR_INVALID_ARG_TYPE (due to calling finished instead of nextTick).
// It&#x27;s not currently worth complicating the code to mimic this.
if (errInflate &#x26;&#x26; errInflate.code === &#x27;ERR_INVALID_CALLBACK&#x27;) {
  assert.deepStrictEqual(errAuto, errInflate);
} else {
  assert.deepStrictEqual(
    errAuto instanceof Error,
    errInflate instanceof Error,
  );
}
// Streams may not emit any events.
// End comparison after event queue clears.
setImmediate(() =&#x3E; result.end());
return result;</code></pre></dd>
                <dt>errors for non-undefined/null falsey argument type</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
let errInflate;
try { zlibStream.close(false); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.close(false); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);
// Streams may not emit any events.
// End comparison after event queue clears.
setImmediate(() =&#x3E; result.end());
return result;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getFormat()</h1>
              <dl>
                <dt>returns format set by #setFormat()</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(Decompress);
assert.strictEqual(inflateAuto.getFormat(), Decompress);</code></pre></dd>
                <dt>returns custom format set by #setFormat()</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(MyDecompress);
assert.strictEqual(inflateAuto.getFormat(), MyDecompress);</code></pre></dd>
                <dt>returns the detected format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.on(&#x27;format&#x27;, () =&#x3E; {
  assert.strictEqual(inflateAuto.getFormat(), Decompress);
  done();
});
inflateAuto.write(compressed);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#flush()</h1>
              <dl>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.flush();
inflateAuto.flush();
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>Z_FINISH before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.flush(zlib.Z_FINISH);
inflateAuto.flush(zlib.Z_FINISH);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.write(compressed.slice(0, 4));
inflateAuto.write(compressed.slice(0, 4));
result.checkpoint();
zlibStream.flush();
inflateAuto.flush();
result.checkpoint();
zlibStream.end(compressed.slice(4));
inflateAuto.end(compressed.slice(4));
result.checkpoint();
return result;</code></pre></dd>
                <dt>Z_FINISH between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.write(compressed.slice(0, 4));
inflateAuto.write(compressed.slice(0, 4));
result.checkpoint();
zlibStream.flush(zlib.Z_FINISH);
inflateAuto.flush(zlib.Z_FINISH);
result.checkpoint();
zlibStream.end(compressed.slice(4));
inflateAuto.end(compressed.slice(4));
result.checkpoint();
return result;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#params()</h1>
              <dl>
                <dt>has the same type</dt>
                <dd><pre><code>let autoType = typeof InflateAuto.prototype.params;
let zlibType = typeof Decompress.prototype.params;
assert.strictEqual(autoType, zlibType);
autoType = typeof new InflateAuto().params;
zlibType = typeof new Decompress().params;
assert.strictEqual(autoType, zlibType);</code></pre></dd>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const level = zlib.Z_BEST_COMPRESSION;
const strategy = zlib.Z_FILTERED;
zlibStream.params(level, strategy, (err) =&#x3E; {
  assert.ifError(err);
  zlibStream.end(compressed);
});
inflateAuto.params(level, strategy, (err) =&#x3E; {
  assert.ifError(err);
  inflateAuto.end(compressed);
});
result.checkpoint();
return result;</code></pre></dd>
                <dt>between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const partial = compressed.slice(0, 4);
return Promise.all([
  zlibWriteP.call(zlibStream, partial),
  autoWriteP.call(inflateAuto, partial),
]).then(() =&#x3E; {
  result.checkpoint();
  const remainder = compressed.slice(4);
  zlibStream.params(
    zlib.Z_BEST_COMPRESSION,
    zlib.Z_FILTERED,
    (err) =&#x3E; {
      assert.ifError(err);
      zlibStream.end(remainder);
    },
  );
  inflateAuto.params(
    zlib.Z_BEST_COMPRESSION,
    zlib.Z_FILTERED,
    (err) =&#x3E; {
      assert.ifError(err);
      inflateAuto.end(remainder);
    },
  );
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#reset()</h1>
              <dl>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.reset();
inflateAuto.reset();
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>discards partial header</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const dataAuto = [];
inflateAuto.on(&#x27;data&#x27;, (data) =&#x3E; {
  dataAuto.push(data);
});
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const partial = compressed.slice(0, 1);
return Promise.all([
  zlibWriteP.call(zlibStream, partial),
  autoWriteP.call(inflateAuto, partial),
]).then(() =&#x3E; {
  result.checkpoint();
  // IMPORTANT:  Can&#x27;t call Zlib.reset() with write in progress
  // Since write is run from uv work queue thread and reset from main
  zlibStream.reset();
  inflateAuto.reset();
  result.checkpoint();
  zlibStream.end(compressed);
  inflateAuto.end(compressed);
  result.checkpoint();
  // Gunzip gained reset in v6.0.0
  // https://github.com/nodejs/node/commit/f380db23
  // If zlib stream emits a header error, test for success instead of ==
  return new Promise((resolve, reject) =&#x3E; {
    let headerError = false;
    zlibStream.once(&#x27;error&#x27;, (err) =&#x3E; {
      if (err.message === &#x27;incorrect header check&#x27;) {
        headerError = true;
        // Comparison result ignored.  Suppress unhandled rejection.
        result.catch((errResult) =&#x3E; {});
      }
    });
    zlibStream.once(&#x27;end&#x27;, () =&#x3E; {
      resolve(result);
    });
    inflateAuto.once(&#x27;end&#x27;, () =&#x3E; {
      assert.deepStrictEqual(Buffer.concat(dataAuto), uncompressed);
      if (headerError) {
        resolve();
      }
    });
  });
});</code></pre></dd>
                <dt>forgets partial header</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
// Note:  Only write to inflateAuto since zlib stream could error on
// first byte due to invalid header.
const autoWriteP = promisify(inflateAuto.write);
// Write data with a different header before reset to check that reset
// clears any partial-header state.
return autoWriteP.call(inflateAuto, otherCompressed.slice(0, 1))
  .then(() =&#x3E; {
    // IMPORTANT:  Can&#x27;t call Zlib.reset() with write in progress
    // Since write is run from uv work queue thread and reset from main
    zlibStream.reset();
    inflateAuto.reset();
    result.checkpoint();
    zlibStream.end(compressed);
    inflateAuto.end(compressed);
    result.checkpoint();
    return result;
  });</code></pre></dd>
                <dt>discards post-header data</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const partial = compressed.slice(0, headerLen + 1);
return Promise.all([
  zlibWriteP.call(zlibStream, partial),
  autoWriteP.call(inflateAuto, partial),
]).then(() =&#x3E; {
  result.checkpoint();
  // IMPORTANT:  Can&#x27;t call Zlib.reset() with write in progress
  // Since write is run from uv work queue thread and reset from main
  zlibStream.reset();
  inflateAuto.reset();
  result.checkpoint();
  zlibStream.end(compressed);
  inflateAuto.end(compressed);
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#setEncoding()</h1>
              <dl>
                <dt>behaves the same before writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.setEncoding(&#x27;utf8&#x27;);
inflateAuto.setEncoding(&#x27;utf8&#x27;);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>behaves the same after format</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const chunk = compressed.slice(0, headerLen + 4);
return Promise.all([
  zlibWriteP.call(zlibStream, chunk),
  autoWriteP.call(inflateAuto, chunk),
]).then(() =&#x3E; {
  result.checkpoint();
  zlibStream.setEncoding(&#x27;utf8&#x27;);
  inflateAuto.setEncoding(&#x27;utf8&#x27;);
  result.checkpoint();
  const rest = compressed.slice(chunk.length);
  zlibStream.end(rest);
  inflateAuto.end(rest);
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#setFormat()</h1>
              <dl>
                <dt>emits &#x27;format&#x27; event with decoder</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
let gotFormat = false;
inflateAuto.on(&#x27;format&#x27;, (decoder) =&#x3E; {
  assert(decoder instanceof Decompress);
  gotFormat = true;
});
inflateAuto.setFormat(Decompress);
assert.strictEqual(gotFormat, true);</code></pre></dd>
                <dt>can set correct format before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>can set incorrect format before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(otherCompressed);
inflateAuto.end(otherCompressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>can set same format twice</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>throws if changing format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(zlib.Inflate);
try {
  inflateAuto.setFormat(zlib.Gunzip);
  throw new Error(&#x27;Should have thrown&#x27;);
} catch (err) {
  assert(/\bformat\b/i.test(err.message));
}</code></pre></dd>
                <dt>throws if changing detected format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.write(otherHeader);
try {
  inflateAuto.setFormat(Decompress);
  throw new Error(&#x27;Should have thrown&#x27;);
} catch (err) {
  assert(/\bformat\b/i.test(err.message));
}</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#_processChunk()</h1>
              <dl>
                <dt>has the same type</dt>
                <dd><pre><code>let autoType = typeof InflateAuto.prototype._processChunk;
let zlibType = typeof Decompress.prototype._processChunk;
assert.strictEqual(autoType, zlibType);
autoType = typeof new InflateAuto()._processChunk;
zlibType = typeof new Decompress()._processChunk;
assert.strictEqual(autoType, zlibType);</code></pre></dd>
                <section class="suite">
                  <h1>with cb</h1>
                  <dl>
                    <dt>works if _transform does not yield synchronously</dt>
                    <dd><pre><code>function AsyncTransform(...args) { stream.Transform.apply(this, args); }
AsyncTransform.prototype = Object.create(stream.Transform.prototype);
AsyncTransform.prototype.constructor = AsyncTransform;
AsyncTransform.prototype._transform = function(data, enc, cb) {
  process.nextTick(() =&#x3E; {
    cb(null, data);
  });
};
const inflateAuto = new InflateAuto({ defaultFormat: AsyncTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH, (err, data) =&#x3E; {
  assert.deepStrictEqual(data, zeros);
  done();
});</code></pre></dd>
                    <dt>buffers inconclusive data</dt>
                    <dd><pre><code>const inflateAuto = new InflateAuto();
const trunc = compressed.slice(0, 1);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
inflateAuto._processChunk(trunc, zlib.Z_NO_FLUSH, (err, data) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(data, undefined);
  done();
});</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>without cb</h1>
                  <dl>
                    <dt>throws if format lacks _processChunk and _transform</dt>
                    <dd><pre><code>function NoTransform(...args) { stream.Duplex.apply(this, args); }
NoTransform.prototype = Object.create(stream.Duplex.prototype);
NoTransform.prototype.constructor = NoTransform;
NoTransform.prototype._read = function() {};
NoTransform.prototype._write = function(chunk, enc, cb) {
  this.push(chunk);
  cb();
};
const inflateAuto = new InflateAuto({ defaultFormat: NoTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH),
  (err) =&#x3E; {
    assert(err instanceof Error);
    assert.strictEqual(err.code, &#x27;ERR_SYNC_NOT_SUPPORTED&#x27;);
    return true;
  },
);</code></pre></dd>
                    <dt>throws if _transform does not yield synchronously</dt>
                    <dd><pre><code>function AsyncTransform(...args) { stream.Transform.apply(this, args); }
AsyncTransform.prototype = Object.create(stream.Transform.prototype);
AsyncTransform.prototype.constructor = AsyncTransform;
AsyncTransform.prototype._transform = function() {};
const inflateAuto = new InflateAuto({ defaultFormat: AsyncTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH),
  (err) =&#x3E; {
    assert(err instanceof Error);
    assert.strictEqual(err.code, &#x27;ERR_SYNC_NOT_SUPPORTED&#x27;);
    return true;
  },
);</code></pre></dd>
                    <dt>throws if _transform yields Error</dt>
                    <dd><pre><code>const errTest = new Error(&#x27;test&#x27;);
function ErrorTransform(...args) { stream.Transform.apply(this, args); }
ErrorTransform.prototype = Object.create(stream.Transform.prototype);
ErrorTransform.prototype.constructor = ErrorTransform;
ErrorTransform.prototype._transform = function(data, enc, cb) {
  cb(errTest);
};
const inflateAuto = new InflateAuto({ defaultFormat: ErrorTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; {
    inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH);
  },
  (err) =&#x3E; err === errTest,
);</code></pre></dd>
                    <dt>supports non-Buffer TypedArray</dt>
                    <dd><pre><code>const compressedTA = new Uint8Array(compressed);
const dataDecompress =
  new Decompress()._processChunk(compressedTA, zlib.Z_FINISH);
const dataAuto =
  new InflateAuto()._processChunk(compressedTA, zlib.Z_FINISH);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                    <dt>supports ArrayBuffer</dt>
                    <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
// As of Node v14, this would cause an assertion failure
// Test that InflateAuto matches Buffer/TypedArray behavior
const dataDecompress =
  new Decompress()._processChunk(compressed, zlib.Z_FINISH);
const dataAuto =
  new InflateAuto()._processChunk(compressedBuf, zlib.Z_FINISH);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                    <dt>throws for invalid chunk type</dt>
                    <dd><pre><code>// As of Node v14, this would cause an assertion failure
// Test that InflateAuto throws TypeError
assert.throws(
  () =&#x3E; new InflateAuto()._processChunk(10, zlib.Z_FINISH),
  TypeError,
);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>DeflateRaw support</h1>
          <dl>
            <dt>as synchronous function</dt>
            <dd><pre><code>const dataDecompress = decompressSync(compressed);
const dataAuto = InflateAuto.inflateAutoSync(compressed);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
            <dt>single-write with immediate end</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
            <dt>single-write delayed end</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
return Promise.all([
  zlibWriteP.call(zlibStream, compressed),
  autoWriteP.call(inflateAuto, compressed),
]).then(() =&#x3E; {
  result.checkpoint();
  zlibStream.end();
  inflateAuto.end();
  result.checkpoint();
  return result;
});</code></pre></dd>
            <dt>1 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>2 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>3 byte writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
for (let i = 0; i &#x3C; compressed.length; i += 1) {
  const block = compressed.slice(i * blockSize, (i + 1) * blockSize);
  zlibStream.write(block);
  inflateAuto.write(block);
  result.checkpoint();
}
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>no writes</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
            <dt>no data after header</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(header);
inflateAuto.end(header);
result.checkpoint();
return result;</code></pre></dd>
            <dt>1 bytes of Gzip header</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const compareOptions = {
  ...COMPARE_OPTIONS,
  compare: compareMaybeFinish,
};
const result =
  streamCompare(inflateAuto, zlibStream, compareOptions);
const partial = formatHeader.slice(0, len);
zlibStream.end(partial);
inflateAuto.end(partial);
result.checkpoint();
return result;</code></pre></dd>
            <dt>2 bytes of Gzip header</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const compareOptions = {
  ...COMPARE_OPTIONS,
  compare: compareMaybeFinish,
};
const result =
  streamCompare(inflateAuto, zlibStream, compareOptions);
const partial = formatHeader.slice(0, len);
zlibStream.end(partial);
inflateAuto.end(partial);
result.checkpoint();
return result;</code></pre></dd>
            <dt>1 bytes of Deflate header</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const compareOptions = {
  ...COMPARE_OPTIONS,
  compare: compareMaybeFinish,
};
const result =
  streamCompare(inflateAuto, zlibStream, compareOptions);
const partial = formatHeader.slice(0, len);
zlibStream.end(partial);
inflateAuto.end(partial);
result.checkpoint();
return result;</code></pre></dd>
            <dt>compressed empty data</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(emptyCompressed);
inflateAuto.end(emptyCompressed);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles truncated compressed data</dt>
            <dd><pre><code>// Truncate shortly after the header (if any) for type detection
const truncated = compressed.slice(0, headerLen + 1);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(truncated);
inflateAuto.end(truncated);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated compressed data</dt>
            <dd><pre><code>const doubledata = Buffer.concat([compressed, compressed]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(doubledata);
inflateAuto.end(doubledata);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated empty compressed data</dt>
            <dd><pre><code>const doubleempty = Buffer.concat([emptyCompressed, emptyCompressed]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(doubleempty);
inflateAuto.end(doubleempty);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated 0</dt>
            <dd><pre><code>const zeros = Buffer.alloc(20);
const compressedWithZeros = Buffer.concat([compressed, zeros]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithZeros);
inflateAuto.end(compressedWithZeros);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles concatenated garbage</dt>
            <dd><pre><code>const garbage = Buffer.alloc(20, 42);
const compressedWithGarbage = Buffer.concat([compressed, garbage]);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithGarbage);
inflateAuto.end(compressedWithGarbage);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles corrupted compressed data</dt>
            <dd><pre><code>const corrupted = Buffer.from(compressed);
// Leave signature intact
corrupted.fill(42, headerLen);
const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(corrupted);
inflateAuto.end(corrupted);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles dictionary</dt>
            <dd><pre><code>const options = { dictionary: uncompressed };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithDict);
inflateAuto.end(compressedWithDict);
result.checkpoint();
return result;</code></pre></dd>
            <dt>handles missing dictionary</dt>
            <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(compressedWithDict);
inflateAuto.end(compressedWithDict);
result.checkpoint();
return result;</code></pre></dd>
            <dt>emits error for format error in _flush</dt>
            <dd><pre><code>const inflateAuto = new InflateAuto({ defaultFormat: null });
const truncated = compressed.slice(0, 1);
inflateAuto.on(&#x27;error&#x27;, (err) =&#x3E; {
  assert(err, &#x27;expected format error&#x27;);
  assert(/format/i.test(err.message));
  assert.deepStrictEqual(err.data, truncated);
  done();
});
inflateAuto.end(truncated);</code></pre></dd>
            <dt>errors on write of invalid type</dt>
            <dd><pre><code>const options = { objectMode: true };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const compareOptions = { ...COMPARE_OPTIONS };
compareOptions.endEvents = [&#x27;end&#x27;];
// nodejs/node@b514bd231 (Node 8) changed Error to TypeError.
if (nodeVersion[0] &#x3C; 8) {
  compareOptions.compare = compareNoErrorTypes;
}
const result = streamCompare(inflateAuto, zlibStream, compareOptions);
let errInflate;
try {
  zlibStream.write(true);
} catch (err) {
  errInflate = err;
}
let errAuto;
try {
  inflateAuto.write(true);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
            <section class="suite">
              <h1>.inflateAuto</h1>
              <dl>
                <dt>decompresses all data in a single call</dt>
                <dd><pre><code>decompress(compressed, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(compressed, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>handles compressed empty data</dt>
                <dd><pre><code>decompress(emptyCompressed, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(emptyCompressed, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports non-Buffer TypedArray</dt>
                <dd><pre><code>const compressedTA = new Uint8Array(compressed);
decompress(compressedTA, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  InflateAuto.inflateAuto(compressedTA, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports ArrayBuffer</dt>
                <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
decompress(compressedBuf, (errDecompress, dataDecompress) =&#x3E; {
  InflateAuto.inflateAuto(compressedBuf, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>can accept options argument</dt>
                <dd><pre><code>const opts = { chunkSize: zlib.Z_MIN_CHUNK };
InflateAuto.inflateAuto(compressed, opts, (errAuto, dataAuto) =&#x3E; {
  assert.ifError(errAuto);
  // Node 0.10 does not support opts
  if (decompress.length &#x3C; 3) {
    done();
    return;
  }
  decompress(compressed, opts, (errDecompress, dataDecompress) =&#x3E; {
    assert.ifError(errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>supports options.info</dt>
                <dd><pre><code>const opts = { info: true };
decompress(compressed, opts, (errDecompress, dataDecompress) =&#x3E; {
  assert.ifError(errDecompress);
  assertInstanceOf(dataDecompress.engine, Decompress);
  InflateAuto.inflateAuto(compressed, opts, (errAuto, dataAuto) =&#x3E; {
    assert.ifError(errAuto);
    assertInstanceOf(dataAuto.engine, InflateAuto);
    dataAuto.engine = dataDecompress.engine;
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>can use PassThrough as defaultFormat</dt>
                <dd><pre><code>const opts = { defaultFormat: stream.PassThrough };
InflateAuto.inflateAuto(uncompressed, opts, (errAuto, dataAuto) =&#x3E; {
  assert.ifError(errAuto);
  assert.deepStrictEqual(dataAuto, uncompressed);
  done();
});</code></pre></dd>
                <dt>handles string defaultEncoding like zlib</dt>
                <dd><pre><code>const compressedStr = compressed.toString(&#x27;binary&#x27;);
const opts = { defaultEncoding: &#x27;binary&#x27; };
decompress(
  compressedStr,
  opts,
  (errDecompress, dataDecompress) =&#x3E; {
    InflateAuto.inflateAuto(
      compressedStr,
      opts,
      (errAuto, dataAuto) =&#x3E; {
        assert.deepStrictEqual(errAuto, errDecompress);
        assert.deepStrictEqual(dataAuto, dataDecompress);
        done();
      },
    );
  },
);</code></pre></dd>
                <dt>passes format Error to the callback like zlib</dt>
                <dd><pre><code>const zeros = Buffer.alloc(20);
decompress(zeros, (errDecompress, dataDecompress) =&#x3E; {
  assert(errDecompress, &#x27;expected Error to test&#x27;);
  InflateAuto.inflateAuto(zeros, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>handles truncated header like zlib</dt>
                <dd><pre><code>const trunc = compressed.slice(0, 1);
decompress(trunc, (errDecompress, dataDecompress) =&#x3E; {
  InflateAuto.inflateAuto(trunc, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
                <dt>handles string argument like zlib</dt>
                <dd><pre><code>const compressedStr = compressed.toString(&#x27;binary&#x27;);
decompress(compressedStr, (errDecompress, dataDecompress) =&#x3E; {
  InflateAuto.inflateAuto(compressedStr, (errAuto, dataAuto) =&#x3E; {
    assert.deepStrictEqual(errAuto, errDecompress);
    assert.deepStrictEqual(dataAuto, dataDecompress);
    done();
  });
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>.inflateAutoSync()</h1>
              <dl>
                <dt>invalid type synchronously</dt>
                <dd><pre><code>let errInflate;
try {
  decompressSync(true);
} catch (err) {
  errInflate = err;
}
let errAuto;
try {
  InflateAuto.inflateAutoSync(true);
} catch (err) {
  errAuto = err;
}
if (errAuto &#x26;&#x26; errInflate) {
  // message changed in 2ced07c (Node 8).  Ignore in comparison.
  errAuto.message = errInflate.message;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                <dt>supports non-Buffer TypedArray</dt>
                <dd><pre><code>const compressedTA = new Uint8Array(compressed);
const dataDecompress = decompressSync(compressedTA);
const dataAuto = InflateAuto.inflateAutoSync(compressedTA);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                <dt>supports ArrayBuffer</dt>
                <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
const dataDecompress = decompressSync(compressedBuf);
const dataAuto = InflateAuto.inflateAutoSync(compressedBuf);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                <dt>supports options.info</dt>
                <dd><pre><code>const options = { info: true };
const dataDecompress = decompressSync(compressed, options);
assertInstanceOf(dataDecompress.engine, Decompress);
const dataAuto = InflateAuto.inflateAutoSync(compressed, options);
assertInstanceOf(dataAuto.engine, InflateAuto);
dataAuto.engine = dataDecompress.engine;
assert.deepStrictEqual(dataAuto, dataDecompress);
assert.deepStrictEqual(dataAuto[0], dataDecompress[0]);</code></pre></dd>
                <dt>partial Gzip header</dt>
                <dd><pre><code>const partial = formatHeader.slice(0, 1);
let dataInflate, errInflate;
try {
  dataInflate = decompressSync(partial);
} catch (err) {
  errInflate = err;
}
let dataAuto, errAuto;
try {
  dataAuto = InflateAuto.inflateAutoSync(partial);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);
assert.deepStrictEqual(dataAuto, dataInflate);</code></pre></dd>
                <dt>partial Deflate header</dt>
                <dd><pre><code>const partial = formatHeader.slice(0, 1);
let dataInflate, errInflate;
try {
  dataInflate = decompressSync(partial);
} catch (err) {
  errInflate = err;
}
let dataAuto, errAuto;
try {
  dataAuto = InflateAuto.inflateAutoSync(partial);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);
assert.deepStrictEqual(dataAuto, dataInflate);</code></pre></dd>
                <dt>can use PassThrough as defaultFormat</dt>
                <dd><pre><code>const opts = { defaultFormat: stream.PassThrough };
const dataAuto = InflateAuto.inflateAutoSync(uncompressed, opts);
assert.deepStrictEqual(dataAuto, uncompressed);</code></pre></dd>
                <dt>handles string argument like zlib</dt>
                <dd><pre><code>const compressedStr = compressed.toString(&#x27;binary&#x27;);
let dataInflate, errInflate;
try {
  dataInflate = decompressSync(compressedStr);
} catch (err) {
  errInflate = err;
}
let dataAuto, errAuto;
try {
  dataAuto = InflateAuto.inflateAutoSync(compressedStr);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);
assert.deepStrictEqual(dataAuto, dataInflate);</code></pre></dd>
                <dt>handles string with defaultEncoding like zlib</dt>
                <dd><pre><code>const compressedStr = compressed.toString(&#x27;binary&#x27;);
const opts = { defaultEncoding: &#x27;binary&#x27; };
let dataInflate, errInflate;
try {
  dataInflate = decompressSync(compressedStr, opts);
} catch (err) {
  errInflate = err;
}
let dataAuto, errAuto;
try {
  dataAuto = InflateAuto.inflateAutoSync(compressedStr, opts);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);
assert.deepStrictEqual(dataAuto, dataInflate);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>Constructor</h1>
              <dl>
                <dt>supports chunkSize</dt>
                <dd><pre><code>const options = { chunkSize: zlib.Z_MIN_CHUNK };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.end(largeCompressed);
inflateAuto.end(largeCompressed);
return result;</code></pre></dd>
                <dt>supports finishFlush</dt>
                <dd><pre><code>const options = { finishFlush: zlib.Z_SYNC_FLUSH };
const zlibStream = new Decompress(options);
const inflateAuto = new InflateAuto(options);
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const truncated = largeCompressed.slice(0, -1);
zlibStream.end(truncated);
inflateAuto.end(truncated);
return result;</code></pre></dd>
                <section class="suite">
                  <h1>validates</h1>
                  <dl>
                    <dt>{ chunkSize: 63 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ chunkSize: NaN }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ flush: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>{ finishFlush: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
let errAuto;
// eslint-disable-next-line no-new
try { new InflateAuto(options); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>emits error</h1>
                  <dl>
                    <dt>synchronously with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { dictionary: true }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { level: -2 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { memLevel: 0 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { strategy: -1 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                    <dt>synchronously with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
let errAuto;
try {
  InflateAuto.inflateAutoSync(compressed, options);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>on write with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
return assertWriteError(
  new InflateAuto(options),
  compressed,
  (errAuto) =&#x3E; assert.deepStrictEqual(errAuto, errInflate),
);</code></pre></dd>
                    <dt>on end with { windowBits: 7 }</dt>
                    <dd><pre><code>let errInflate;
// eslint-disable-next-line no-new
try { new Decompress(options); } catch (err) { errInflate = err; }
assert(errInflate);
const inflateAuto = new InflateAuto({
  ...options,
  defaultFormat: Decompress,
});
let errorEmitted = false;
inflateAuto.on(&#x27;error&#x27;, (errAuto) =&#x3E; {
  assert(!errorEmitted, &#x27;error emitted at most once&#x27;);
  errorEmitted = true;
  assert.deepStrictEqual(errAuto, errInflate);
});
inflateAuto.end((errAuto) =&#x3E; {
  assert(errorEmitted, &#x27;error emitted at least once&#x27;);
  // Errors passed to _flush callback may not be passed to end cb.
  if (errAuto) {
    assert.deepStrictEqual(errAuto, errInflate);
  }
  done();
});</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>#close()</h1>
              <dl>
                <dt>without writing</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
return new Promise((resolve, reject) =&#x3E; {
  zlibStream.close((...zlibArgs) =&#x3E; {
    inflateAuto.close((...inflateArgs) =&#x3E; {
      // Before nodejs/node#32220 (v14) an error is not passed.
      // Not worth the effort to match this behavior.  Always error.
      if (zlibArgs[0] === undefined) {
        assert.deepStrictEqual(
          inflateArgs.slice(1),
          zlibArgs.slice(1),
          &#x27;same non-err close arguments&#x27;,
        );
        assertInstanceOf(inflateArgs[0], Error);
        assert.deepStrictEqual(
          inflateArgs[0].code,
          &#x27;ERR_STREAM_PREMATURE_CLOSE&#x27;,
        );
      } else {
        assert.deepStrictEqual(
          inflateArgs,
          zlibArgs,
          &#x27;same close arguments&#x27;,
        );
      }
      resolve(result);
    });
  });
});</code></pre></dd>
                <dt>emits once for multiple calls</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
let closeEmitted = false;
inflateAuto.on(&#x27;close&#x27;, () =&#x3E; {
  assert.strictEqual(closeEmitted, false);
  closeEmitted = true;
});
inflateAuto.once(&#x27;close&#x27;, () =&#x3E; {
  inflateAuto.close();
});
inflateAuto.close();
inflateAuto.close();
return new Promise((resolve, reject) =&#x3E; {
  setImmediate(() =&#x3E; {
    assert.strictEqual(closeEmitted, true);
    resolve();
  });
});</code></pre></dd>
                <dt>before #end()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
zlibStream.end();
inflateAuto.end();
result.checkpoint();
return result;</code></pre></dd>
                <dt>#reset() after #close()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
let errInflate;
try { zlibStream.reset(); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.reset(); } catch (err) { errAuto = err; }
// nodejs/node@6441556 (v6.2.1) changed the assertion to check _handle
// which is null rather than false in this case.
//
// nodejs/node#25956 (v12) changed from ERR_ASSERTION to
// ERR_INTERNAL_ASSERTION.
//
// It&#x27;s not worth complicating the code to mimic this.
assert.deepStrictEqual(
  errAuto instanceof Error,
  errInflate instanceof Error,
);
return result;</code></pre></dd>
                <dt>#write() after #close()</dt>
                <dd><pre><code>const zlibStream = new zlib.Inflate();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.close();
inflateAuto.close();
result.checkpoint();
return new Promise((resolve, reject) =&#x3E; {
  const writeArgsByCall = [];
  function onWrite(...writeArgs) {
    writeArgsByCall.push(writeArgs);
    if (writeArgsByCall.length === 2) {
      assert.deepStrictEqual(writeArgsByCall[0], writeArgsByCall[1]);
      resolve(result);
    }
  }
  zlibStream.write(Buffer.alloc(0), onWrite);
  inflateAuto.write(Buffer.alloc(0), onWrite);
  result.checkpoint();
});</code></pre></dd>
                <dt>errors for non-function truthy argument type</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
let errInflate;
try { zlibStream.close(true); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.close(true); } catch (err) { errAuto = err; }
// In nodejs/node#32220 the error changed from ERR_INVALID_CALLBACK
// to ERR_INVALID_ARG_TYPE (due to calling finished instead of nextTick).
// It&#x27;s not currently worth complicating the code to mimic this.
if (errInflate &#x26;&#x26; errInflate.code === &#x27;ERR_INVALID_CALLBACK&#x27;) {
  assert.deepStrictEqual(errAuto, errInflate);
} else {
  assert.deepStrictEqual(
    errAuto instanceof Error,
    errInflate instanceof Error,
  );
}
// Streams may not emit any events.
// End comparison after event queue clears.
setImmediate(() =&#x3E; result.end());
return result;</code></pre></dd>
                <dt>errors for non-undefined/null falsey argument type</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
let errInflate;
try { zlibStream.close(false); } catch (err) { errInflate = err; }
let errAuto;
try { inflateAuto.close(false); } catch (err) { errAuto = err; }
assert.deepStrictEqual(errAuto, errInflate);
// Streams may not emit any events.
// End comparison after event queue clears.
setImmediate(() =&#x3E; result.end());
return result;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#getFormat()</h1>
              <dl>
                <dt>returns format set by #setFormat()</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(Decompress);
assert.strictEqual(inflateAuto.getFormat(), Decompress);</code></pre></dd>
                <dt>returns custom format set by #setFormat()</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(MyDecompress);
assert.strictEqual(inflateAuto.getFormat(), MyDecompress);</code></pre></dd>
                <dt>returns the detected format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.on(&#x27;format&#x27;, () =&#x3E; {
  assert.strictEqual(inflateAuto.getFormat(), Decompress);
  done();
});
inflateAuto.write(compressed);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#flush()</h1>
              <dl>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.flush();
inflateAuto.flush();
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>Z_FINISH before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.flush(zlib.Z_FINISH);
inflateAuto.flush(zlib.Z_FINISH);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.write(compressed.slice(0, 4));
inflateAuto.write(compressed.slice(0, 4));
result.checkpoint();
zlibStream.flush();
inflateAuto.flush();
result.checkpoint();
zlibStream.end(compressed.slice(4));
inflateAuto.end(compressed.slice(4));
result.checkpoint();
return result;</code></pre></dd>
                <dt>Z_FINISH between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.write(compressed.slice(0, 4));
inflateAuto.write(compressed.slice(0, 4));
result.checkpoint();
zlibStream.flush(zlib.Z_FINISH);
inflateAuto.flush(zlib.Z_FINISH);
result.checkpoint();
zlibStream.end(compressed.slice(4));
inflateAuto.end(compressed.slice(4));
result.checkpoint();
return result;</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#params()</h1>
              <dl>
                <dt>has the same type</dt>
                <dd><pre><code>let autoType = typeof InflateAuto.prototype.params;
let zlibType = typeof Decompress.prototype.params;
assert.strictEqual(autoType, zlibType);
autoType = typeof new InflateAuto().params;
zlibType = typeof new Decompress().params;
assert.strictEqual(autoType, zlibType);</code></pre></dd>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const level = zlib.Z_BEST_COMPRESSION;
const strategy = zlib.Z_FILTERED;
zlibStream.params(level, strategy, (err) =&#x3E; {
  assert.ifError(err);
  zlibStream.end(compressed);
});
inflateAuto.params(level, strategy, (err) =&#x3E; {
  assert.ifError(err);
  inflateAuto.end(compressed);
});
result.checkpoint();
return result;</code></pre></dd>
                <dt>between writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const partial = compressed.slice(0, 4);
return Promise.all([
  zlibWriteP.call(zlibStream, partial),
  autoWriteP.call(inflateAuto, partial),
]).then(() =&#x3E; {
  result.checkpoint();
  const remainder = compressed.slice(4);
  zlibStream.params(
    zlib.Z_BEST_COMPRESSION,
    zlib.Z_FILTERED,
    (err) =&#x3E; {
      assert.ifError(err);
      zlibStream.end(remainder);
    },
  );
  inflateAuto.params(
    zlib.Z_BEST_COMPRESSION,
    zlib.Z_FILTERED,
    (err) =&#x3E; {
      assert.ifError(err);
      inflateAuto.end(remainder);
    },
  );
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#reset()</h1>
              <dl>
                <dt>before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.reset();
inflateAuto.reset();
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>discards post-header data</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const partial = compressed.slice(0, headerLen + 1);
return Promise.all([
  zlibWriteP.call(zlibStream, partial),
  autoWriteP.call(inflateAuto, partial),
]).then(() =&#x3E; {
  result.checkpoint();
  // IMPORTANT:  Can&#x27;t call Zlib.reset() with write in progress
  // Since write is run from uv work queue thread and reset from main
  zlibStream.reset();
  inflateAuto.reset();
  result.checkpoint();
  zlibStream.end(compressed);
  inflateAuto.end(compressed);
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#setEncoding()</h1>
              <dl>
                <dt>behaves the same before writes</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
zlibStream.setEncoding(&#x27;utf8&#x27;);
inflateAuto.setEncoding(&#x27;utf8&#x27;);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>behaves the same after format</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zlibWriteP = promisify(zlibStream.write);
const autoWriteP = promisify(inflateAuto.write);
const chunk = compressed.slice(0, headerLen + 4);
return Promise.all([
  zlibWriteP.call(zlibStream, chunk),
  autoWriteP.call(inflateAuto, chunk),
]).then(() =&#x3E; {
  result.checkpoint();
  zlibStream.setEncoding(&#x27;utf8&#x27;);
  inflateAuto.setEncoding(&#x27;utf8&#x27;);
  result.checkpoint();
  const rest = compressed.slice(chunk.length);
  zlibStream.end(rest);
  inflateAuto.end(rest);
  result.checkpoint();
  return result;
});</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#setFormat()</h1>
              <dl>
                <dt>emits &#x27;format&#x27; event with decoder</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
let gotFormat = false;
inflateAuto.on(&#x27;format&#x27;, (decoder) =&#x3E; {
  assert(decoder instanceof Decompress);
  gotFormat = true;
});
inflateAuto.setFormat(Decompress);
assert.strictEqual(gotFormat, true);</code></pre></dd>
                <dt>can set correct format before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>can set incorrect format before write</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(otherCompressed);
inflateAuto.end(otherCompressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>can set same format twice</dt>
                <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result = streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
inflateAuto.setFormat(Decompress);
inflateAuto.setFormat(Decompress);
result.checkpoint();
zlibStream.end(compressed);
inflateAuto.end(compressed);
result.checkpoint();
return result;</code></pre></dd>
                <dt>throws if changing format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.setFormat(zlib.Inflate);
try {
  inflateAuto.setFormat(zlib.Gunzip);
  throw new Error(&#x27;Should have thrown&#x27;);
} catch (err) {
  assert(/\bformat\b/i.test(err.message));
}</code></pre></dd>
                <dt>throws if changing detected format</dt>
                <dd><pre><code>const inflateAuto = new InflateAuto();
inflateAuto.write(otherHeader);
try {
  inflateAuto.setFormat(Decompress);
  throw new Error(&#x27;Should have thrown&#x27;);
} catch (err) {
  assert(/\bformat\b/i.test(err.message));
}</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#_processChunk()</h1>
              <dl>
                <dt>has the same type</dt>
                <dd><pre><code>let autoType = typeof InflateAuto.prototype._processChunk;
let zlibType = typeof Decompress.prototype._processChunk;
assert.strictEqual(autoType, zlibType);
autoType = typeof new InflateAuto()._processChunk;
zlibType = typeof new Decompress()._processChunk;
assert.strictEqual(autoType, zlibType);</code></pre></dd>
                <section class="suite">
                  <h1>with cb</h1>
                  <dl>
                    <dt>emits error without calling callback</dt>
                    <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result =
  streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zeros = Buffer.alloc(10);
zlibStream._processChunk(zeros, zlib.Z_FINISH, neverCalled);
inflateAuto._processChunk(zeros, zlib.Z_FINISH, neverCalled);
result.checkpoint();
return result;</code></pre></dd>
                    <dt>yields format error</dt>
                    <dd><pre><code>const inflateAuto = new InflateAuto({ defaultFormat: null });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH, (err) =&#x3E; {
  assert(err, &#x27;expected format error&#x27;);
  assert(/format/i.test(err.message));
  assert.deepStrictEqual(err.data, zeros);
  done();
});</code></pre></dd>
                    <dt>works if _transform does not yield synchronously</dt>
                    <dd><pre><code>function AsyncTransform(...args) { stream.Transform.apply(this, args); }
AsyncTransform.prototype = Object.create(stream.Transform.prototype);
AsyncTransform.prototype.constructor = AsyncTransform;
AsyncTransform.prototype._transform = function(data, enc, cb) {
  process.nextTick(() =&#x3E; {
    cb(null, data);
  });
};
const inflateAuto = new InflateAuto({ defaultFormat: AsyncTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH, (err, data) =&#x3E; {
  assert.deepStrictEqual(data, zeros);
  done();
});</code></pre></dd>
                    <dt>buffers inconclusive data</dt>
                    <dd><pre><code>const inflateAuto = new InflateAuto();
const trunc = compressed.slice(0, 1);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
inflateAuto._processChunk(trunc, zlib.Z_NO_FLUSH, (err, data) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(data, undefined);
  done();
});</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>without cb</h1>
                  <dl>
                    <dt>throws without error listener</dt>
                    <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const zeros = Buffer.alloc(10);
let errInflate;
try {
  zlibStream._processChunk(zeros, zlib.Z_FINISH);
} catch (err) {
  errInflate = err;
}
let errAuto;
try {
  inflateAuto._processChunk(zeros, zlib.Z_FINISH);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);</code></pre></dd>
                    <dt>throws with error listener</dt>
                    <dd><pre><code>const zlibStream = new Decompress();
const inflateAuto = new InflateAuto();
const result =
  streamCompare(inflateAuto, zlibStream, COMPARE_OPTIONS);
const zeros = Buffer.alloc(10);
let errInflate;
try {
  zlibStream._processChunk(zeros, zlib.Z_FINISH);
} catch (err) {
  errInflate = err;
}
let errAuto;
try {
  inflateAuto._processChunk(zeros, zlib.Z_FINISH);
} catch (err) {
  errAuto = err;
}
assert.deepStrictEqual(errAuto, errInflate);
result.checkpoint();</code></pre></dd>
                    <dt>throws format errors</dt>
                    <dd><pre><code>const inflateAuto = new InflateAuto({ defaultFormat: null });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(() =&#x3E; {
  inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH);
});</code></pre></dd>
                    <dt>throws if format lacks _processChunk and _transform</dt>
                    <dd><pre><code>function NoTransform(...args) { stream.Duplex.apply(this, args); }
NoTransform.prototype = Object.create(stream.Duplex.prototype);
NoTransform.prototype.constructor = NoTransform;
NoTransform.prototype._read = function() {};
NoTransform.prototype._write = function(chunk, enc, cb) {
  this.push(chunk);
  cb();
};
const inflateAuto = new InflateAuto({ defaultFormat: NoTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH),
  (err) =&#x3E; {
    assert(err instanceof Error);
    assert.strictEqual(err.code, &#x27;ERR_SYNC_NOT_SUPPORTED&#x27;);
    return true;
  },
);</code></pre></dd>
                    <dt>throws if _transform does not yield synchronously</dt>
                    <dd><pre><code>function AsyncTransform(...args) { stream.Transform.apply(this, args); }
AsyncTransform.prototype = Object.create(stream.Transform.prototype);
AsyncTransform.prototype.constructor = AsyncTransform;
AsyncTransform.prototype._transform = function() {};
const inflateAuto = new InflateAuto({ defaultFormat: AsyncTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH),
  (err) =&#x3E; {
    assert(err instanceof Error);
    assert.strictEqual(err.code, &#x27;ERR_SYNC_NOT_SUPPORTED&#x27;);
    return true;
  },
);</code></pre></dd>
                    <dt>throws if _transform yields Error</dt>
                    <dd><pre><code>const errTest = new Error(&#x27;test&#x27;);
function ErrorTransform(...args) { stream.Transform.apply(this, args); }
ErrorTransform.prototype = Object.create(stream.Transform.prototype);
ErrorTransform.prototype.constructor = ErrorTransform;
ErrorTransform.prototype._transform = function(data, enc, cb) {
  cb(errTest);
};
const inflateAuto = new InflateAuto({ defaultFormat: ErrorTransform });
const zeros = Buffer.alloc(10);
inflateAuto.on(&#x27;error&#x27;, () =&#x3E; {
  throw new Error(&#x27;error should not be emitted&#x27;);
});
assert.throws(
  () =&#x3E; {
    inflateAuto._processChunk(zeros, zlib.Z_NO_FLUSH);
  },
  (err) =&#x3E; err === errTest,
);</code></pre></dd>
                    <dt>supports non-Buffer TypedArray</dt>
                    <dd><pre><code>const compressedTA = new Uint8Array(compressed);
const dataDecompress =
  new Decompress()._processChunk(compressedTA, zlib.Z_FINISH);
const dataAuto =
  new InflateAuto()._processChunk(compressedTA, zlib.Z_FINISH);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                    <dt>supports ArrayBuffer</dt>
                    <dd><pre><code>const compressedBuf = compressed.buffer.slice(
  compressed.byteOffset,
  compressed.byteOffset + compressed.length,
);
// As of Node v14, this would cause an assertion failure
// Test that InflateAuto matches Buffer/TypedArray behavior
const dataDecompress =
  new Decompress()._processChunk(compressed, zlib.Z_FINISH);
const dataAuto =
  new InflateAuto()._processChunk(compressedBuf, zlib.Z_FINISH);
assert.deepStrictEqual(dataAuto, dataDecompress);</code></pre></dd>
                    <dt>throws for invalid chunk type</dt>
                    <dd><pre><code>// As of Node v14, this would cause an assertion failure
// Test that InflateAuto throws TypeError
assert.throws(
  () =&#x3E; new InflateAuto()._processChunk(10, zlib.Z_FINISH),
  TypeError,
);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
